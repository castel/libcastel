%token_prefix P9_LEXER_MANGLEDTOKENS_
%token_type   { lexer::Lexeme *     }

%left Assign.
%left Add Substract.
%left Multiply Divide Modulo.
%left Call.

%left LParenthesis RParenthesis.

%nonassoc Spaces Newline.
%nonassoc Indent Dedent.

%include {

    #include <cassert>

    #include "p9/ast/expr/Binary.hh"
    #include "p9/ast/expr/Call.hh"
    #include "p9/ast/expr/Function.hh"
    #include "p9/ast/expr/Number.hh"
    #include "p9/ast/expr/Variable.hh"
    #include "p9/ast/stmt/decl/Variables.hh"
    #include "p9/ast/stmt/Expression.hh"
    #include "p9/ast/stmt/Return.hh"
    #include "p9/ast/Expression.hh"
    #include "p9/ast/Statement.hh"
    #include "p9/lexer/Lexeme.hh"
    #include "p9/lexer/Token.hh"

    using namespace p9;

    static bool p9parserIsValid;
    static ast::Statement * p9parserRootStatement;

}

%syntax_error {
    p9parserIsValid = false;
}

%type program                                                                                                    { ast::Statement *           }
program ::= statements(U).                                                                                       { p9parserRootStatement = U; }

%type statements                                                                                                 { ast::Statement * }
statements(A) ::= statementlist(U).                                                                              { A = U;           }
statements(A) ::= .                                                                                              { A = nullptr;     }

%type statementlist                                                                                              { ast::Statement *     }
statementlist(A) ::= statement(U) Newline statements(V).                                                         { A = U; A->next( V ); }
statementlist(A) ::= Newline statements(U).                                                                      { A = U;               }
statementlist(A) ::= statement(U).                                                                               { A = U;               }

%type statement                                                                                                  { ast::Statement * }
statement(A) ::= expressionstatement(U).                                                                         { A = U;           }
statement(A) ::= returnstatement(U).                                                                             { A = U;           }
statement(A) ::= variabledeclarationstatement(U).                                                                { A = U;           }

%type expressionstatement                                                                                        { ast::stmt::Expression *             }
expressionstatement(A) ::= expression(U).                                                                        { A = new ast::stmt::Expression( U ); }

%type returnstatement                                                                                            { ast::stmt::Return *             }
returnstatement(A) ::= Return.                                                                                   { A = new ast::stmt::Return( );   }
returnstatement(A) ::= Return expression(U).                                                                     { A = new ast::stmt::Return( U ); }

%type variabledeclarationstatement                                                                               { ast::stmt::decl::Variables *                           }
variabledeclarationstatement(A) ::= Var variabledeclaration(U) variabledeclarationlist(V).                       { A = new ast::stmt::decl::Variables( U ); U->next( V ); }

%type variabledeclaration                                                                                        { ast::stmt::decl::Variables::Variable *              }
variabledeclaration(A) ::= Identifier(U).                                                                        { A = new ast::stmt::decl::Variables::Variable( *U ); }

%type variabledeclarationlist                                                                                    { ast::stmt::decl::Variables::Variable * }
variabledeclarationlist(A) ::= Comma variabledeclaration(U) variabledeclarationlist(V).                          { A = U; U->next( V );                   }
variabledeclarationlist(A) ::= .                                                                                 { A = nullptr;                           }

%type expression                                                                                                 { ast::Expression * }
expression(A) ::= callexpression(U).                                                                             { A = U;            }
expression(A) ::= binaryexpression(U).                                                                           { A = U;            }
expression(A) ::= numberexpression(U).                                                                           { A = U;            }
expression(A) ::= functionexpression(U).                                                                         { A = U;            }
expression(A) ::= variableexpression(U).                                                                         { A = U;            }

%type binaryexpression                                                                                           { ast::expr::Binary *                                   }
binaryexpression(A) ::= expression(U) Add       expression(V).                                                   { A = new ast::expr::Binary( lexer::TAdd,       U, V ); }
binaryexpression(A) ::= expression(U) Substract expression(V).                                                   { A = new ast::expr::Binary( lexer::TSubstract, U, V ); }
binaryexpression(A) ::= expression(U) Multiply  expression(V).                                                   { A = new ast::expr::Binary( lexer::TMultiply,  U, V ); }
binaryexpression(A) ::= expression(U) Divide    expression(V).                                                   { A = new ast::expr::Binary( lexer::TDivide,    U, V ); }
binaryexpression(A) ::= expression(U) Modulo    expression(V).                                                   { A = new ast::expr::Binary( lexer::TModulo,    U, V ); }
binaryexpression(A) ::= expression(U) Assign    expression(V).                                                   { A = new ast::expr::Binary( lexer::TAssign,    U, V ); }

%type callexpression                                                                                             { ast::expr::Call *                }
callexpression(A) ::= expression(U) arguments(V).                                                                { A = new ast::expr::Call( U, V ); }

%type arguments                                                                                                  { ast::expr::Call::Argument * }
arguments(A) ::= LParenthesis RParenthesis.                                                                      { A = nullptr;                }
arguments(A) ::= LParenthesis argumentlist(U) RParenthesis.                                                      { A = U;                      }

%type argumentlist                                                                                               { ast::expr::Call::Argument *                           }
argumentlist(A) ::= expression(U) Comma argumentlist(V).                                                         { A = new ast::expr::Call::Argument( U ); A->next( V ); }
argumentlist(A) ::= expression(U).                                                                               { A = new ast::expr::Call::Argument( U );               }

%type numberexpression                                                                                           { ast::expr::Number *              }
numberexpression(A) ::= Number(U).                                                                               { A = new ast::expr::Number( *U ); }

%type variableexpression                                                                                         { ast::expr::Variable *              }
variableexpression(A) ::= Identifier(U).                                                                         { A = new ast::expr::Variable( *U ); }

%type functionexpression                                                                                         { ast::expr::Function *                }
functionexpression(A) ::= LParenthesis Function parameters(U) Colon Indent statementlist(V) Dedent RParenthesis. { A = new ast::expr::Function( U, V ); }

%type parameters                                                                                                 { ast::expr::Function::Parameter * }
parameters(A) ::= LParenthesis parameterlist(U) RParenthesis.                                                    { A = U;                           }
parameters(A) ::= LParenthesis RParenthesis.                                                                     { A = nullptr;                     }
parameters(A) ::= .                                                                                              { A = nullptr;                     }

%type parameterlist                                                                                              { ast::expr::Function::Parameter *                            }
parameterlist(A) ::= Identifier(U) Comma parameterlist(V).                                                       { A = new ast::expr::Function::Parameter( *U ); A->next( V ); }
parameterlist(A) ::= Identifier(U).                                                                              { A = new ast::expr::Function::Parameter( *U );               }
