%token_prefix CASTEL_LEXER_MANGLEDLEXEMESTYPES_
%token_type   { lexer::Lexeme *     }

%left Assign.
%left Add Substract.
%left Multiply Divide Modulo.
%left Call.

%left LParenthesis RParenthesis.

%nonassoc Spaces Newline.
%nonassoc Indent Dedent.

%include {

    #include <cassert>

    #include "castel/ast/expr/Boolean.hh"
    #include "castel/ast/expr/Binary.hh"
    #include "castel/ast/expr/Call.hh"
    #include "castel/ast/expr/Function.hh"
    #include "castel/ast/expr/Null.hh"
    #include "castel/ast/expr/Number.hh"
    #include "castel/ast/expr/Undefined.hh"
    #include "castel/ast/expr/Variable.hh"
    #include "castel/ast/stmt/decl/Variables.hh"
    #include "castel/ast/stmt/Expression.hh"
    #include "castel/ast/stmt/If.hh"
    #include "castel/ast/stmt/Return.hh"
    #include "castel/ast/Expression.hh"
    #include "castel/ast/Statement.hh"
    #include "castel/lexer/Lexeme.hh"

    using namespace castel;

    static bool castelparserIsValid;
    static ast::Statement * castelparserRootStatement;

}

%syntax_error {
    castelparserIsValid = false;
}

%type program                                                                                       { ast::Statement *           }
program ::= statements(U).                                                                          { castelparserRootStatement = U; }

%type statementlist                                                                                 { ast::Statement *     }
statementlist(A) ::= emptystatementlist statement(U) statementlist(V).                              { A = U; U->next( V ); }
statementlist(A) ::= emptystatementlist.                                                            { A = nullptr;         }

%type statements                                                                                    { ast::Statement *     }
statements(A) ::= emptystatementlist statement(U) statementlist(V).                                 { A = U; A->next( V ); }

%type emptystatementlist                                                                            { void *          }
emptystatementlist ::= Newline emptystatementlist.                                                  { /* no action */ }
emptystatementlist ::= .                                                                            { /* no action */ }

%type statementblock                                                                                { ast::Statement * }
statementblock(A) ::= Indent statements(U) Dedent.                                                  { A = U;           }

%type statement                                                                                     { ast::Statement * }
statement(A) ::= expressionstatement(U).                                                            { A = U;           }
statement(A) ::= returnstatement(U).                                                                { A = U;           }
statement(A) ::= variabledeclarationstatement(U).                                                   { A = U;           }
statement(A) ::= ifstatement(U).                                                                    { A = U;           }

%type expressionstatement                                                                           { ast::stmt::Expression *             }
expressionstatement(A) ::= expression(U) Newline.                                                   { A = new ast::stmt::Expression( U ); }

%type returnstatement                                                                               { ast::stmt::Return *             }
returnstatement(A) ::= Return Newline.                                                              { A = new ast::stmt::Return( );   }
returnstatement(A) ::= Return expression(U) Newline.                                                { A = new ast::stmt::Return( U ); }

%type variabledeclarationstatement                                                                  { ast::stmt::decl::Variables *             }
variabledeclarationstatement(A) ::= Var variabledeclarations(U) Newline.                            { A = new ast::stmt::decl::Variables( U ); }

%type variabledeclarations                                                                          { ast::stmt::decl::Variables::Variable * }
variabledeclarations(A) ::= variabledeclaration(U) Comma variabledeclarations(V).                   { A = U; U->next( V );                   }
variabledeclarations(A) ::= variabledeclaration(U).                                                 { A = U;                                 }

%type variabledeclaration                                                                           { ast::stmt::decl::Variables::Variable *                  }
variabledeclaration(A) ::= Identifier(U).                                                           { A = new ast::stmt::decl::Variables::Variable( *U );     }
variabledeclaration(A) ::= Identifier(U) Assign expression(V).                                      { A = new ast::stmt::decl::Variables::Variable( *U, V ); }

%type ifstatement                                                                                   { ast::stmt::If *                   }
ifstatement(A) ::= If expression(U) Colon statementblock(V) Else Colon statementblock(W).           { A = new ast::stmt::If( U, V, W ); }
ifstatement(A) ::= If expression(U) Colon statementblock(V).                                        { A = new ast::stmt::If( U, V );    }

%type expression                                                                                    { ast::Expression * }
expression(A) ::= booleanexpression(U).                                                             { A = U;            }
expression(A) ::= binaryexpression(U).                                                              { A = U;            }
expression(A) ::= callexpression(U).                                                                { A = U;            }
expression(A) ::= functionexpression(U).                                                            { A = U;            }
expression(A) ::= nullexpression(U).                                                                { A = U;            }
expression(A) ::= numberexpression(U).                                                              { A = U;            }
expression(A) ::= parenthesisexpression(U).                                                         { A = U;            }
expression(A) ::= undefinedexpression(U).                                                           { A = U;            }
expression(A) ::= variableexpression(U).                                                            { A = U;            }

%type booleanexpression                                                                             { ast::expr::Boolean * }
booleanexpression(A) ::= False.                                                                     { A = new ast::expr::Boolean( false ); }
booleanexpression(A) ::= True.                                                                      { A = new ast::expr::Boolean( true );  }

%type binaryexpression                                                                              { ast::expr::Binary *                                                }
binaryexpression(A) ::= expression(U) Add       expression(V).                                      { A = new ast::expr::Binary( lexer::Lexeme::Type::Add,       U, V ); }
binaryexpression(A) ::= expression(U) Substract expression(V).                                      { A = new ast::expr::Binary( lexer::Lexeme::Type::Substract, U, V ); }
binaryexpression(A) ::= expression(U) Multiply  expression(V).                                      { A = new ast::expr::Binary( lexer::Lexeme::Type::Multiply,  U, V ); }
binaryexpression(A) ::= expression(U) Divide    expression(V).                                      { A = new ast::expr::Binary( lexer::Lexeme::Type::Divide,    U, V ); }
binaryexpression(A) ::= expression(U) Modulo    expression(V).                                      { A = new ast::expr::Binary( lexer::Lexeme::Type::Modulo,    U, V ); }
binaryexpression(A) ::= expression(U) Assign    expression(V).                                      { A = new ast::expr::Binary( lexer::Lexeme::Type::Assign,    U, V ); }

%type callexpression                                                                                { ast::expr::Call *                }
callexpression(A) ::= expression(U) arguments(V).                                                   { A = new ast::expr::Call( U, V ); }

%type arguments                                                                                     { ast::expr::Call::Argument * }
arguments(A) ::= LParenthesis RParenthesis.                                                         { A = nullptr;                }
arguments(A) ::= LParenthesis argumentlist(U) RParenthesis.                                         { A = U;                      }

%type argumentlist                                                                                  { ast::expr::Call::Argument *                           }
argumentlist(A) ::= expression(U) Comma argumentlist(V).                                            { A = new ast::expr::Call::Argument( U ); A->next( V ); }
argumentlist(A) ::= expression(U).                                                                  { A = new ast::expr::Call::Argument( U );               }

%type functionexpression                                                                            { ast::expr::Function *                }
functionexpression(A) ::= LParenthesis Function parameters(U) Colon statementblock(V) RParenthesis. { A = new ast::expr::Function( U, V ); }

%type nullexpression                                                                                { ast::expr::Null *           }
nullexpression(A) ::= Null.                                                                         { A = new ast::expr::Null( ); }

%type numberexpression                                                                              { ast::expr::Number *              }
numberexpression(A) ::= Number(U).                                                                  { A = new ast::expr::Number( *U ); }

%type parenthesisexpression                                                                         { ast::Expression * }
parenthesisexpression(A) ::= LParenthesis expression(U) RParenthesis.                               { A = U;            }

%type undefinedexpression                                                                           { ast::expr::Undefined *           }
undefinedexpression(A) ::= Undefined.                                                               { A = new ast::expr::Undefined( ); }

%type variableexpression                                                                            { ast::expr::Variable *              }
variableexpression(A) ::= Identifier(U).                                                            { A = new ast::expr::Variable( *U ); }

%type parameters                                                                                    { ast::expr::Function::Parameter * }
parameters(A) ::= parameterlist(U).                                                                 { A = U;                           }
parameters(A) ::= .                                                                                 { A = nullptr;                     }

%type parameterlist                                                                                 { ast::expr::Function::Parameter *                            }
parameterlist(A) ::= Identifier(U) Comma parameterlist(V).                                          { A = new ast::expr::Function::Parameter( *U ); A->next( V ); }
parameterlist(A) ::= Identifier(U).                                                                 { A = new ast::expr::Function::Parameter( *U );               }
