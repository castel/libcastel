%token_prefix CASTEL_LEXER_MANGLEDLEXEMESTYPES_
%token_type   { lexer::Lexeme *     }

%left Incrementation Decrementation LParenthesis LBracket.
%left PositiveAddition NegativeSubstraction.
%left Multiplication Division Modulo.
%left Assignment AdditionAssignment SubstractionAssignment MultiplicationAssignment DivisionAssignment ModuloAssignment.

%nonassoc Spaces Newline.
%nonassoc Indent Dedent.

%include {

    #include <cassert>
    #include <list>
    #include <string>

    #include "castel/ast/expr/Boolean.hh"
    #include "castel/ast/expr/Binary.hh"
    #include "castel/ast/expr/Class.hh"
    #include "castel/ast/expr/Dict.hh"
    #include "castel/ast/expr/Function.hh"
    #include "castel/ast/expr/List.hh"
    #include "castel/ast/expr/Multary.hh"
    #include "castel/ast/expr/Null.hh"
    #include "castel/ast/expr/Number.hh"
    #include "castel/ast/expr/String.hh"
    #include "castel/ast/expr/Unary.hh"
    #include "castel/ast/expr/Undefined.hh"
    #include "castel/ast/expr/Variable.hh"
    #include "castel/ast/stmt/decl/Variables.hh"
    #include "castel/ast/stmt/Expression.hh"
    #include "castel/ast/stmt/If.hh"
    #include "castel/ast/stmt/Return.hh"
    #include "castel/ast/Expression.hh"
    #include "castel/ast/Statement.hh"

    using namespace castel;

    static bool castelparserIsValid;
    static ast::Statement * castelparserRootStatement;
    static std::list< std::string > castelparserExpectedTokens;

}

%syntax_error {
    castelparserIsValid = false;
    int n = sizeof( yyTokenName ) / sizeof( yyTokenName[ 0 ] );
    for ( int i = 0; i < n; ++ i ) {
        int a = yy_find_shift_action( yypParser, static_cast< YYCODETYPE >( i ) );
        if ( a < YYNSTATE + YYNRULE ) {
            castelparserExpectedTokens.push_back( yyTokenName[ i ] );
        }
    }
}

%type program { ast::Statement * }
program ::= statementlist(U). { castelparserRootStatement = U; }

    %type statementlist { ast::Statement * }
    statementlist(A) ::= emptystatementlist statementlistiterator(U). { A = U; }

    %type statementblock { ast::Statement * }
    statementblock(A) ::= Indent statementlist(U) Dedent. { A = U; }

    %type statementlistiterator { ast::Statement * }
    statementlistiterator(A) ::= . { A = nullptr; }
    statementlistiterator(A) ::= statement(U) emptystatementlist statementlistiterator(V). { A = U; U->next( V ); }

        emptystatementlist ::= Newline emptystatementlist.
        emptystatementlist ::= .

    %type statement { ast::Statement * }
    statement(A) ::= expressionstatement(U). { A = U; }
    statement(A) ::= returnstatement(U). { A = U; }
    statement(A) ::= variabledeclarationstatement(U). { A = U; }
    statement(A) ::= ifstatement(U). { A = U; }

        %type expressionstatement { ast::stmt::Expression * }
        expressionstatement(A) ::= expression(U) Newline. { A = new ast::stmt::Expression( U ); }

        %type ifstatement { ast::stmt::If * }
        ifstatement(A) ::= If expression(U) Colon statement(V). { A = new ast::stmt::If( U, V ); }
        ifstatement(A) ::= If expression(U) Colon statementblock(V) Else Colon statementblock(W). { A = new ast::stmt::If( U, V, W ); }
        ifstatement(A) ::= If expression(U) Colon statementblock(V). { A = new ast::stmt::If( U, V );    }

        %type returnstatement { ast::stmt::Return * }
        returnstatement(A) ::= Return Newline. { A = new ast::stmt::Return( ); }
        returnstatement(A) ::= Return expression(U) Newline. { A = new ast::stmt::Return( U ); }

        %type variabledeclarationstatement { ast::stmt::decl::Variables * }
        variabledeclarationstatement(A) ::= Var variabledeclarations(U) Newline. { A = new ast::stmt::decl::Variables( U ); }

        %type variabledeclarations { ast::stmt::decl::Variables::Variable * }
        variabledeclarations(A) ::= variabledeclaration(U) Comma variabledeclarations(V). { A = U; U->next( V ); }
        variabledeclarations(A) ::= variabledeclaration(U). { A = U; }

        %type variabledeclaration { ast::stmt::decl::Variables::Variable * }
        variabledeclaration(A) ::= Identifier(U). { A = new ast::stmt::decl::Variables::Variable( * U ); }
        variabledeclaration(A) ::= Identifier(U) Assignment expression(V). { A = new ast::stmt::decl::Variables::Variable( * U, V ); }

%type expression { ast::Expression * }
expression(A) ::= assignmentexpression(U). { A = U; }

    %type assignmentexpression { ast::Expression * }
    assignmentexpression(A) ::= conditionalexpression(U). { A = U; }
    assignmentexpression(A) ::= assignmentexpression(U) assignmentoperator(V) conditionalexpression(W). { A = new ast::expr::Binary( V, U, W ); }

        %type assignmentoperator { ast::expr::Binary::Operator }
        assignmentoperator(A) ::= Assignment. { A = ast::expr::Binary::Operator::Assignment; }
        assignmentoperator(A) ::= AdditionAssignment. { A = ast::expr::Binary::Operator::NumericAssignmentAddition; }
        assignmentoperator(A) ::= SubstractionAssignment. { A = ast::expr::Binary::Operator::NumericAssignmentSubstraction; }
        assignmentoperator(A) ::= MultiplicationAssignment. { A = ast::expr::Binary::Operator::NumericAssignmentMultiplication; }
        assignmentoperator(A) ::= DivisionAssignment. { A = ast::expr::Binary::Operator::NumericDivision; }
        assignmentoperator(A) ::= ModuloAssignment. { A = ast::expr::Binary::Operator::NumericModulo; }

        %type conditionalexpression { ast::Expression * }
        conditionalexpression(A) ::= binaryexpression(U). { A = U; }
        conditionalexpression(A) ::= conditionalexpression(U) conditionaloperator(V) binaryexpression(W). { A = new ast::expr::Binary( V, U, W ); }

            %type conditionaloperator { ast::expr::Binary::Operator }
            conditionaloperator(A) ::= And. { A = ast::expr::Binary::Operator::LogicAnd; }
            conditionaloperator(A) ::= Or. { A = ast::expr::Binary::Operator::LogicOr; }

            %type binaryexpression { ast::Expression * }
            binaryexpression(A) ::= comparisonexpression(U). { A = U; }

                %type comparisonexpression { ast::Expression * }
                comparisonexpression(A) ::= shiftexpression(U). { A = U; }
                comparisonexpression(A) ::= comparisonexpression(U) comparisonoperator(V) shiftexpression(W). { A = new ast::expr::Binary( V, U, W ); }

                    %type comparisonoperator { ast::expr::Binary::Operator }
                    comparisonoperator(A) ::= Lesser. { A = ast::expr::Binary::Operator::ComparisonLesser; }
                    comparisonoperator(A) ::= Greater. { A = ast::expr::Binary::Operator::ComparisonGreater; }
                    comparisonoperator(A) ::= LesserOrEqual. { A = ast::expr::Binary::Operator::ComparisonLesserOrEqual; }
                    comparisonoperator(A) ::= GreaterOrEqual. { A = ast::expr::Binary::Operator::ComparisonGreaterOrEqual; }
                    comparisonoperator(A) ::= Equal. { A = ast::expr::Binary::Operator::ComparisonEqual; }
                    comparisonoperator(A) ::= NotEqual. { A = ast::expr::Binary::Operator::ComparisonNotEqual; }

                    %type shiftexpression { ast::Expression * }
                    shiftexpression(A) ::= additiveexpression(U). { A = U; }

                        %type additiveexpression { ast::Expression * }
                        additiveexpression(A) ::= multiplicativeexpression(U). { A = U; }
                        additiveexpression(A) ::= additiveexpression(U) additiveoperator(V) multiplicativeexpression(W). { A = new ast::expr::Binary( V, U, W ); }

                            %type additiveoperator { ast::expr::Binary::Operator }
                            additiveoperator(A) ::= PositiveAddition. { A = ast::expr::Binary::Operator::NumericAddition; }
                            additiveoperator(A) ::= NegativeSubstractionHyphen. { A = ast::expr::Binary::Operator::NumericSubstraction; }

                            %type multiplicativeexpression { ast::Expression * }
                            multiplicativeexpression(A) ::= prefixexpression(U). { A = U; }
                            multiplicativeexpression(A) ::= multiplicativeexpression(U) multiplicativeoperator(V) prefixexpression(W). { A = new ast::expr::Binary( V, U, W ); }

                                %type multiplicativeoperator { ast::expr::Binary::Operator }
                                multiplicativeoperator(A) ::= Multiplication. { A = ast::expr::Binary::Operator::NumericMultiplication; }
                                multiplicativeoperator(A) ::= Division. { A = ast::expr::Binary::Operator::NumericDivision; }
                                multiplicativeoperator(A) ::= Modulo. { A = ast::expr::Binary::Operator::NumericModulo; }

                                    %type prefixexpression { ast::Expression * }
                                    prefixexpression(A) ::= postfixexpression(U). { A = U; }
                                    prefixexpression(A) ::= prefixoperator(U) prefixexpression(V). { A = new ast::expr::Unary( U, V ); }

                                        %type prefixoperator { ast::expr::Unary::Operator }
                                        prefixoperator(A) ::= PositiveAddition. { A = ast::expr::Unary::Operator::NumericPlus; }
                                        prefixoperator(A) ::= NegativeSubstractionHyphen. { A = ast::expr::Unary::Operator::NumericMinus; }
                                        prefixoperator(A) ::= Incrementation. { A = ast::expr::Unary::Operator::NumericPreIncrementation; }
                                        prefixoperator(A) ::= Decrementation. { A = ast::expr::Unary::Operator::NumericPreDecrementation; }

                                        %type postfixexpression { ast::Expression * }
                                        postfixexpression(A) ::= newexpression(U). { A = U; }
                                        postfixexpression(A) ::= postfixexpression(U) postfixoperator(V). { A = new ast::expr::Unary( V, U ); }
                                        postfixexpression(A) ::= postfixexpression(U) callexpression(V). { A = new ast::expr::Multary( ast::expr::Multary::Operator::Call, U ); U->next( V ); }
                                        postfixexpression(A) ::= postfixexpression(U) subscriptexpression(V). { A = new ast::expr::Multary( ast::expr::Multary::Operator::Subscript, U ); U->next( V ); }
                                        postfixexpression(A) ::= postfixexpression(U) Dot Identifier(V). { A = new ast::expr::Binary( ast::expr::Binary::Operator::Member, U, new ast::expr::String( V->as< std::string >( ) ) ); }

                                            %type postfixoperator { ast::expr::Unary::Operator }
                                            postfixoperator(A) ::= Incrementation. { A = ast::expr::Unary::Operator::NumericPostIncrementation; }
                                            postfixoperator(A) ::= Decrementation. { A = ast::expr::Unary::Operator::NumericPostDecrementation; }

                                            %type callexpression { ast::Expression * }
                                            callexpression(A) ::= LParenthesis expressionlist(U) RParenthesis. { A = U; }

                                            %type subscriptexpression { ast::Expression * }
                                            subscriptexpression(A) ::= LBracket expressionlist(U) RBracket. { A = U; }

                                                %type expressionlist { ast::Expression * }
                                                expressionlist(A) ::= . { A = nullptr; }
                                                expressionlist(A) ::= expressioniterator(U). { A = U; }

                                                    %type expressioniterator { ast::Expression * }
                                                    expressioniterator(A) ::= expression(U). { A = U; }
                                                    expressioniterator(A) ::= expression(U) Comma expressioniterator(V). { A = U; A->next( V ); }

                                            %type newexpression { ast::Expression * }
                                            newexpression(A) ::= primaryexpression(U). { A = U; }
                                            newexpression(A) ::= New newexpression(U) callexpression(V). { A = new ast::expr::Multary( ast::expr::Multary::Operator::New, U ); U->next( V ); }

                                                %type primaryexpression { ast::Expression * }
                                                primaryexpression(A) ::= Identifier(U). { A = new ast::expr::Variable( * U ); }
                                                primaryexpression(A) ::= literal(U). { A = U; }
                                                primaryexpression(A) ::= LParenthesis expression(U) RParenthesis. { A = U; }

                                                    %type literal { ast::Expression * }
                                                    literal(A) ::= nullliteral(U). { A = U; }
                                                    literal(A) ::= undefinedliteral(U). { A = U; }
                                                    literal(A) ::= booleanliteral(U). { A = U; }
                                                    literal(A) ::= numberliteral(U). { A = U; }
                                                    literal(A) ::= functionliteral(U). { A = U; }
                                                    literal(A) ::= stringliteral(U). { A = U; }
                                                    literal(A) ::= dictliteral(U). { A = U; }
                                                    literal(A) ::= listliteral(U). { A = U; }
                                                    literal(A) ::= classliteral(U). { A = U; }

                                                        %type nullliteral { ast::expr::Null * }
                                                        nullliteral(A) ::= Null. { A = new ast::expr::Null( ); }

                                                        %type undefinedliteral { ast::expr::Undefined * }
                                                        undefinedliteral(A) ::= Undefined. { A = new ast::expr::Undefined( ); }

                                                        %type booleanliteral { ast::expr::Boolean * }
                                                        booleanliteral(A) ::= True. { A = new ast::expr::Boolean( true ); }
                                                        booleanliteral(A) ::= False. { A = new ast::expr::Boolean( false ); }

                                                        %type numberliteral { ast::expr::Number * }
                                                        numberliteral(A) ::= Number(U). { A = new ast::expr::Number( * U ); }

                                                        %type stringliteral { ast::expr::String * }
                                                        stringliteral(A) ::= String(U). { A = new ast::expr::String( * U ); }

                                                        %type dictliteral { ast::expr::Dict * }
                                                        dictliteral(A) ::= LParenthesis Dict RParenthesis. { A = new ast::expr::Dict( ); }
                                                        dictliteral(A) ::= LParenthesis Dict Colon dictblock(U) RParenthesis. { A = new ast::expr::Dict( U ); }

                                                            %type dictitem { ast::expr::Dict::Item * }
                                                            dictitem(A) ::= Identifier(U) Colon expression(V). { A = new ast::expr::Dict::Item( * U, V ); }

                                                            %type dictblock { ast::expr::Dict::Item * }
                                                            dictblock(A) ::= Indent dictblockiterator(U) Dedent. { A = U; }

                                                                %type dictblockiterator { ast::expr::Dict::Item * }
                                                                dictblockiterator(A) ::= dictitem(U). { A = U; }
                                                                dictblockiterator(A) ::= dictitem(U) Newline dictblockiterator(V). { A = U; A->next( V ); }

                                                        %type listliteral { ast::expr::List * }
                                                        listliteral(A) ::= LParenthesis List RParenthesis. { A = new ast::expr::List( ); }
                                                        listliteral(A) ::= LParenthesis List Colon listblock(U) RParenthesis. { A = new ast::expr::List( U ); }

                                                            %type listitem { ast::expr::List::Item * }
                                                            listitem(A) ::= NegativeSubstractionHyphen expression(U). { A = new ast::expr::List::Item( U ); }

                                                            %type listblock { ast::expr::List::Item * }
                                                            listblock(A) ::= Indent listblockiterator(U) Dedent. { A = U; }

                                                                %type listblockiterator { ast::expr::List::Item * }
                                                                listblockiterator(A) ::= listitem(U). { A = U; }
                                                                listblockiterator(A) ::= listitem(U) Newline listblockiterator(V). { A = U; A->next( V ); }

                                                        %type functionliteral { ast::expr::Function * }
                                                        functionliteral(A) ::= LParenthesis Function parameterlist(U) Colon statementblock(V) RParenthesis. { A = new ast::expr::Function( U, V ); }

                                                            %type parameterlist { ast::Parameter * }
                                                            parameterlist(A) ::= . { A = nullptr; }
                                                            parameterlist(A) ::= parameterlistiterator(U). { A = U; }

                                                                %type parameterlistiterator { ast::Parameter * }
                                                                parameterlistiterator(A) ::= parameter(U). { A = U; }
                                                                parameterlistiterator(A) ::= parameter(U) Comma parameterlistiterator(V). { A = U; A->next( V ); }

                                                                    %type parameter { ast::Parameter * }
                                                                    parameter(A) ::= Identifier(U). { A = new ast::Parameter( U->as< std::string >( ) ); }

                                                        %type classliteral { ast::expr::Class * }
                                                        classliteral(A) ::= LParenthesis Class Colon classblock(V) RParenthesis. { A = new ast::expr::Class( V ); }

                                                            %type classblock { ast::expr::Class::Member * }
                                                            classblock(A) ::= Indent classblockiterator(U) Dedent. { A = U; }

                                                                %type classblockiterator { ast::expr::Class::Member * }
                                                                classblockiterator(A) ::= member(U). { A = U; }
                                                                classblockiterator(A) ::= member(U) classblockiterator(V). { A = U; A->next( V ); }

                                                                    %type member { ast::expr::Class::Member * }
                                                                    member(A) ::= visibility(U) Var Identifier(V). { A = new ast::expr::Class::Attribute( U, V->as< std::string >( ) ); }
                                                                    member(A) ::= visibility(U) Function Identifier(V) parameterlist(W) Colon statementblock(X). { A = new ast::expr::Class::Method( U, V->as< std::string >( ), new ast::expr::Function( W, X ) ); }
                                                                    member(A) ::= visibility Function Operator Identifier parameterlist Colon statementblock. { A = nullptr; /* not implemented */ }

                                                                        %type visibility { ast::expr::Class::Member::Visibility }
                                                                        visibility(A) ::= Public. { A = ast::expr::Class::Member::Visibility::Public; }
                                                                        visibility(A) ::= Protected. { A = ast::expr::Class::Member::Visibility::Protected; }
                                                                        visibility(A) ::= Private. { A = ast::expr::Class::Member::Visibility::Private; }
