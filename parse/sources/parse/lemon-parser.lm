%token_prefix CASTEL_LEXING_MANGLEDLEXEMETYPES_
%token_type   { lex::Lexeme *     }

%left Incrementation Decrementation LParenthesis LBracket.
%left PositiveAddition NegativeSubstraction.
%left Multiplication Division Modulo.
%left Assignment AdditionAssignment SubstractionAssignment MultiplicationAssignment DivisionAssignment ModuloAssignment.

%nonassoc Spaces Newline.
%nonassoc Indent Dedent.

%include {

    #include <cassert>
    #include <list>
    #include <string>

    #include "castel/ast/expr/Bool.hh"
    #include "castel/ast/expr/Binary.hh"
    #include "castel/ast/expr/Class.hh"
    #include "castel/ast/expr/Conditional.hh"
    #include "castel/ast/expr/Dict.hh"
    #include "castel/ast/expr/External.hh"
    #include "castel/ast/expr/Function.hh"
    #include "castel/ast/expr/List.hh"
    #include "castel/ast/expr/Multary.hh"
    #include "castel/ast/expr/Null.hh"
    #include "castel/ast/expr/Number.hh"
    #include "castel/ast/expr/String.hh"
    #include "castel/ast/expr/Unary.hh"
    #include "castel/ast/expr/Undefined.hh"
    #include "castel/ast/expr/Variable.hh"
    #include "castel/ast/stmt/decl/Variables.hh"
    #include "castel/ast/stmt/Expression.hh"
    #include "castel/ast/stmt/If.hh"
    #include "castel/ast/stmt/Return.hh"
    #include "castel/ast/Expression.hh"
    #include "castel/ast/Statement.hh"
    #include "castel/lex/Lexeme.hh"

    using namespace castel;

    static bool castelparserIsValid;
    static ast::Statement * castelparserRootStatement;
    static std::list< std::string > castelparserExpectedTokens;

}

%syntax_error {
    castelparserIsValid = false;
    int n = sizeof( yyTokenName ) / sizeof( yyTokenName[ 0 ] );
    for ( int i = 0; i < n; ++ i ) {
        int a = yy_find_shift_action( yypParser, static_cast< YYCODETYPE >( i ) );
        if ( a < YYNSTATE + YYNRULE ) {
            castelparserExpectedTokens.push_back( yyTokenName[ i ] );
        }
    }
}

%type program { ast::Statement * }
program ::= statementlist(U). { castelparserRootStatement = U; }

    %type statementlist { ast::Statement * }
    statementlist(A) ::= emptystatementlist statementlistiterator(U). { A = U; }

    %type statementblock { ast::Statement * }
    statementblock(A) ::= Indent statementlist(U) Dedent. { A = U; }

    %type statementlistiterator { ast::Statement * }
    statementlistiterator(A) ::= . { A = nullptr; }
    statementlistiterator(A) ::= statement(U) emptystatementlist statementlistiterator(V). { A = U; U->next( V ); }

        emptystatementlist ::= Newline emptystatementlist.
        emptystatementlist ::= .

    %type statement { ast::Statement * }
    statement(A) ::= requirestatement(U). { A = U; }
    statement(A) ::= expressionstatement(U). { A = U; }
    statement(A) ::= returnstatement(U). { A = U; }
    statement(A) ::= variabledeclarationstatement(U). { A = U; }
    statement(A) ::= ifstatement(U). { A = U; }

        %type requirestatement { ast::stmt::Require * }
        requirestatement(A) ::= Require String(U) As Identifier(V) Newline. { A = new ast::stmt::Require( U->as< std::string >( ), V->as< std::string >( ) ); }

        %type expressionstatement { ast::stmt::Expression * }
        expressionstatement(A) ::= expression(U) Newline. { A = new ast::stmt::Expression( U ); }

        %type ifstatement { ast::stmt::If * }
        ifstatement(A) ::= If expression(U) Colon statement(V). { A = new ast::stmt::If( U, V ); }
        ifstatement(A) ::= If expression(U) Colon statementblock(V) Else Colon statementblock(W). { A = new ast::stmt::If( U, V, W ); }
        ifstatement(A) ::= If expression(U) Colon statementblock(V). { A = new ast::stmt::If( U, V );    }

        %type returnstatement { ast::stmt::Return * }
        returnstatement(A) ::= Return Newline. { A = new ast::stmt::Return( ); }
        returnstatement(A) ::= Return expression(U) Newline. { A = new ast::stmt::Return( U ); }

        %type variabledeclarationstatement { ast::stmt::decl::Variables * }
        variabledeclarationstatement(A) ::= Var variabledeclarations(U) Newline. { A = new ast::stmt::decl::Variables( U ); }

        %type variabledeclarations { ast::stmt::decl::Variables::Variable * }
        variabledeclarations(A) ::= variabledeclaration(U) Comma variabledeclarations(V). { A = U; U->next( V ); }
        variabledeclarations(A) ::= variabledeclaration(U). { A = U; }

        %type variabledeclaration { ast::stmt::decl::Variables::Variable * }
        variabledeclaration(A) ::= Identifier(U). { A = new ast::stmt::decl::Variables::Variable( U->as< std::string >( ) ); }
        variabledeclaration(A) ::= Identifier(U) Assignment expression(V). { A = new ast::stmt::decl::Variables::Variable( U->as< std::string >( ), V ); }

%type expression { ast::Expression * }
expression(A) ::= assignmentexpression(U). { A = U; }

    %type assignmentexpression { ast::Expression * }
    assignmentexpression(A) ::= conditionalexpression(U). { A = U; }
    assignmentexpression(A) ::= logicalexpression(U) assignmentoperator(V) assignmentexpression(W). { A = new ast::expr::Binary( V, U, W ); }

        %type assignmentoperator { ast::expr::Binary::Operator }
        assignmentoperator(A) ::= Assignment. { A = ast::expr::Binary::Operator::Assignment; }
        assignmentoperator(A) ::= AdditionAssignment. { A = ast::expr::Binary::Operator::NumericAssignmentAddition; }
        assignmentoperator(A) ::= SubstractionAssignment. { A = ast::expr::Binary::Operator::NumericAssignmentSubstraction; }
        assignmentoperator(A) ::= MultiplicationAssignment. { A = ast::expr::Binary::Operator::NumericAssignmentMultiplication; }
        assignmentoperator(A) ::= DivisionAssignment. { A = ast::expr::Binary::Operator::NumericDivision; }
        assignmentoperator(A) ::= ModuloAssignment. { A = ast::expr::Binary::Operator::NumericModulo; }

        %type conditionalexpression { ast::Expression * }
        conditionalexpression(A) ::= logicalexpression(U). { A = U; }
        conditionalexpression(A) ::= logicalexpression(U) QuestionMark expression(V) Colon expression(W). { A = new ast::expr::Conditional( U, V, W ); }

            %type logicalexpression { ast::Expression * }
            logicalexpression(A) ::= binaryexpression(U). { A = U; }
            logicalexpression(A) ::= logicalexpression(U) logicaloperator(V) binaryexpression(W). { A = new ast::expr::Binary( V, U, W ); }

                %type logicaloperator { ast::expr::Binary::Operator }
                logicaloperator(A) ::= And. { A = ast::expr::Binary::Operator::LogicAnd; }
                logicaloperator(A) ::= Or. { A = ast::expr::Binary::Operator::LogicOr; }

                %type binaryexpression { ast::Expression * }
                binaryexpression(A) ::= comparisonexpression(U). { A = U; }

                    %type comparisonexpression { ast::Expression * }
                    comparisonexpression(A) ::= shiftexpression(U). { A = U; }
                    comparisonexpression(A) ::= comparisonexpression(U) comparisonoperator(V) shiftexpression(W). { A = new ast::expr::Binary( V, U, W ); }

                        %type comparisonoperator { ast::expr::Binary::Operator }
                        comparisonoperator(A) ::= Lesser. { A = ast::expr::Binary::Operator::ComparisonLesser; }
                        comparisonoperator(A) ::= Greater. { A = ast::expr::Binary::Operator::ComparisonGreater; }
                        comparisonoperator(A) ::= LesserOrEqual. { A = ast::expr::Binary::Operator::ComparisonLesserOrEqual; }
                        comparisonoperator(A) ::= GreaterOrEqual. { A = ast::expr::Binary::Operator::ComparisonGreaterOrEqual; }
                        comparisonoperator(A) ::= Equal. { A = ast::expr::Binary::Operator::ComparisonEqual; }
                        comparisonoperator(A) ::= NotEqual. { A = ast::expr::Binary::Operator::ComparisonNotEqual; }

                        %type shiftexpression { ast::Expression * }
                        shiftexpression(A) ::= additiveexpression(U). { A = U; }

                            %type additiveexpression { ast::Expression * }
                            additiveexpression(A) ::= multiplicativeexpression(U). { A = U; }
                            additiveexpression(A) ::= additiveexpression(U) additiveoperator(V) multiplicativeexpression(W). { A = new ast::expr::Binary( V, U, W ); }

                                %type additiveoperator { ast::expr::Binary::Operator }
                                additiveoperator(A) ::= PositiveAddition. { A = ast::expr::Binary::Operator::NumericAddition; }
                                additiveoperator(A) ::= NegativeSubstractionHyphen. { A = ast::expr::Binary::Operator::NumericSubstraction; }

                                %type multiplicativeexpression { ast::Expression * }
                                multiplicativeexpression(A) ::= prefixexpression(U). { A = U; }
                                multiplicativeexpression(A) ::= multiplicativeexpression(U) multiplicativeoperator(V) prefixexpression(W). { A = new ast::expr::Binary( V, U, W ); }

                                    %type multiplicativeoperator { ast::expr::Binary::Operator }
                                    multiplicativeoperator(A) ::= Multiplication. { A = ast::expr::Binary::Operator::NumericMultiplication; }
                                    multiplicativeoperator(A) ::= Division. { A = ast::expr::Binary::Operator::NumericDivision; }
                                    multiplicativeoperator(A) ::= Modulo. { A = ast::expr::Binary::Operator::NumericModulo; }

                                        %type prefixexpression { ast::Expression * }
                                        prefixexpression(A) ::= castexpression(U). { A = U; }
                                        prefixexpression(A) ::= prefixoperator(U) castexpression(V). { A = new ast::expr::Unary( U, V ); }

                                            %type prefixoperator { ast::expr::Unary::Operator }
                                            prefixoperator(A) ::= PositiveAddition. { A = ast::expr::Unary::Operator::NumericPlus; }
                                            prefixoperator(A) ::= NegativeSubstractionHyphen. { A = ast::expr::Unary::Operator::NumericMinus; }
                                            prefixoperator(A) ::= Incrementation. { A = ast::expr::Unary::Operator::NumericPreIncrementation; }
                                            prefixoperator(A) ::= Decrementation. { A = ast::expr::Unary::Operator::NumericPreDecrementation; }

                                            %type castexpression { ast::Expression * }
                                            castexpression(A) ::= postfixexpression(U). { A = U; }
                                            castexpression(A) ::= castexpression(U) Quote postfixexpression(V). { A = new ast::expr::Binary( ast::expr::Binary::Operator::Cast, U, V ); }

                                                %type postfixexpression { ast::Expression * }
                                                postfixexpression(A) ::= newexpression(U). { A = U; }
                                                postfixexpression(A) ::= postfixexpression(U) postfixoperator(V). { A = new ast::expr::Unary( V, U ); }
                                                postfixexpression(A) ::= postfixexpression(U) callexpression(V). { A = new ast::expr::Multary( ast::expr::Multary::Operator::Call, U ); U->next( V ); }
                                                postfixexpression(A) ::= postfixexpression(U) subscriptexpression(V). { A = new ast::expr::Multary( ast::expr::Multary::Operator::Subscript, U ); U->next( V ); }
                                                postfixexpression(A) ::= postfixexpression(U) Dot Identifier(V). { A = new ast::expr::Binary( ast::expr::Binary::Operator::Member, U, ast::expr::String::createFromRaw( V->as< std::string >( ) ) ); }

                                                    %type postfixoperator { ast::expr::Unary::Operator }
                                                    postfixoperator(A) ::= Incrementation. { A = ast::expr::Unary::Operator::NumericPostIncrementation; }
                                                    postfixoperator(A) ::= Decrementation. { A = ast::expr::Unary::Operator::NumericPostDecrementation; }

                                                    %type callexpression { ast::Expression * }
                                                    callexpression(A) ::= LParenthesis expressionlist(U) RParenthesis. { A = U; }

                                                    %type subscriptexpression { ast::Expression * }
                                                    subscriptexpression(A) ::= LBracket expressionlist(U) RBracket. { A = U; }

                                                        %type expressionlist { ast::Expression * }
                                                        expressionlist(A) ::= . { A = nullptr; }
                                                        expressionlist(A) ::= expressioniterator(U). { A = U; }

                                                            %type expressioniterator { ast::Expression * }
                                                            expressioniterator(A) ::= expression(U). { A = U; }
                                                            expressioniterator(A) ::= expression(U) Comma expressioniterator(V). { A = U; A->next( V ); }

                                                    %type newexpression { ast::Expression * }
                                                    newexpression(A) ::= primaryexpression(U). { A = U; }
                                                    newexpression(A) ::= New newexpression(U) callexpression(V). { A = new ast::expr::Multary( ast::expr::Multary::Operator::New, U ); U->next( V ); }

                                                        %type primaryexpression { ast::Expression * }
                                                        primaryexpression(A) ::= variable(U). { A = U; }
                                                        primaryexpression(A) ::= external(U). { A = U; }
                                                        primaryexpression(A) ::= literal(U). { A = U; }
                                                        primaryexpression(A) ::= LParenthesis expression(U) RParenthesis. { A = U; }

                                                            %type variable { ast::expr::Variable * }
                                                            variable(A) ::= Identifier(U). { A = new ast::expr::Variable( U->as< std::string >( ) ); }

                                                            %type external { ast::expr::External * }
                                                            external(A) ::= External(U). { A = ast::expr::External::createFromLiteral( U->as< std::string >( ) ); }

                                                            %type literal { ast::Expression * }
                                                            literal(A) ::= nullliteral(U). { A = U; }
                                                            literal(A) ::= undefinedliteral(U). { A = U; }
                                                            literal(A) ::= booleanliteral(U). { A = U; }
                                                            literal(A) ::= numberliteral(U). { A = U; }
                                                            literal(A) ::= functionliteral(U). { A = U; }
                                                            literal(A) ::= stringliteral(U). { A = U; }
                                                            literal(A) ::= dictliteral(U). { A = U; }
                                                            literal(A) ::= listliteral(U). { A = U; }
                                                            literal(A) ::= classliteral(U). { A = U; }

                                                                %type nullliteral { ast::expr::Null * }
                                                                nullliteral(A) ::= Null. { A = new ast::expr::Null( ); }

                                                                %type undefinedliteral { ast::expr::Undefined * }
                                                                undefinedliteral(A) ::= Undefined. { A = new ast::expr::Undefined( ); }

                                                                %type booleanliteral { ast::expr::Bool * }
                                                                booleanliteral(A) ::= True. { A = new ast::expr::Bool( true ); }
                                                                booleanliteral(A) ::= False. { A = new ast::expr::Bool( false ); }

                                                                %type numberliteral { ast::expr::Number * }
                                                                numberliteral(A) ::= Number(U). { A = new ast::expr::Number( U->as< ast::expr::Number::DataType >( ) ); }

                                                                %type stringliteral { ast::expr::String * }
                                                                stringliteral(A) ::= String(U). { A = ast::expr::String::createFromLiteral( U->as< std::string >( ) ); }

                                                                %type dictliteral { ast::expr::Dict * }
                                                                dictliteral(A) ::= LParenthesis Dict RParenthesis. { A = new ast::expr::Dict( nullptr ); }
                                                                dictliteral(A) ::= LParenthesis Dict Colon dictblock(U) RParenthesis. { A = new ast::expr::Dict( U ); }

                                                                    %type dictitem { ast::expr::Dict::Item * }
                                                                    dictitem(A) ::= Identifier(U) Colon expression(V). { A = new ast::expr::Dict::Item( U->as< std::string >( ), V ); }

                                                                    %type dictblock { ast::expr::Dict::Item * }
                                                                    dictblock(A) ::= Indent dictblockiterator(U) Dedent. { A = U; }

                                                                        %type dictblockiterator { ast::expr::Dict::Item * }
                                                                        dictblockiterator(A) ::= dictitem(U). { A = U; }
                                                                        dictblockiterator(A) ::= dictitem(U) Newline dictblockiterator(V). { A = U; A->next( V ); }

                                                                %type listliteral { ast::expr::List * }
                                                                listliteral(A) ::= LParenthesis List RParenthesis. { A = new ast::expr::List( nullptr ); }
                                                                listliteral(A) ::= LParenthesis List Colon listblock(U) RParenthesis. { A = new ast::expr::List( U ); }

                                                                    %type listitem { ast::expr::List::Item * }
                                                                    listitem(A) ::= NegativeSubstractionHyphen expression(U). { A = new ast::expr::List::Item( U ); }

                                                                    %type listblock { ast::expr::List::Item * }
                                                                    listblock(A) ::= Indent listblockiterator(U) Dedent. { A = U; }

                                                                        %type listblockiterator { ast::expr::List::Item * }
                                                                        listblockiterator(A) ::= listitem(U). { A = U; }
                                                                        listblockiterator(A) ::= listitem(U) Newline listblockiterator(V). { A = U; A->next( V ); }

                                                                %type functionliteral { ast::expr::Function * }
                                                                functionliteral(A) ::= LParenthesis Function parameterlist(U) Colon statementblock(V) RParenthesis. { A = new ast::expr::Function( U, V ); }

                                                                    %type parameterlist { ast::expr::Function::Parameter * }
                                                                    parameterlist(A) ::= . { A = nullptr; }
                                                                    parameterlist(A) ::= parameterlistiterator(U). { A = U; }

                                                                        %type parameterlistiterator { ast::expr::Function::Parameter * }
                                                                        parameterlistiterator(A) ::= parameter(U). { A = U; }
                                                                        parameterlistiterator(A) ::= parameter(U) Comma parameterlistiterator(V). { A = U; A->next( V ); }

                                                                            %type parameter { ast::expr::Function::Parameter * }
                                                                            parameter(A) ::= Identifier(U). { A = new ast::expr::Function::Parameter( U->as< std::string >( ) ); }

                                                                %type classliteral { ast::expr::Class * }
                                                                classliteral(A) ::= LParenthesis Class Colon classblock(U) RParenthesis. { A = new ast::expr::Class( U ); }
                                                                classliteral(A) ::= LParenthesis Class Extending expression(U) Colon classblock(V) RParenthesis. { A = new ast::expr::Class( V, U ); }

                                                                    %type classblock { ast::expr::Class::Member * }
                                                                    classblock(A) ::= Indent classblockiterator(U) Dedent. { A = U; }

                                                                        %type classblockiterator { ast::expr::Class::Member * }
                                                                        classblockiterator(A) ::= member(U). { A = U; }
                                                                        classblockiterator(A) ::= member(U) classblockiterator(V). { A = U; A->next( V ); }

                                                                            %type member { ast::expr::Class::Member * }
                                                                            member(A) ::= membervisibility(U) membertype(V) Var Identifier(W) Assignment expression(X) Newline. { A = new ast::expr::Class::Attribute( U, V, W->as< std::string >( ), X ); }
                                                                            member(A) ::= membervisibility(U) membertype(V) Var Identifier(W) Newline. { A = new ast::expr::Class::Attribute( U, V, W->as< std::string >( ) ); }
                                                                            member(A) ::= membervisibility(U) membertype(V) Function Identifier(W) parameterlist(X) Colon statementblock(Y). { A = new ast::expr::Class::Method( U, V, W->as< std::string >( ), new ast::expr::Function( X, Y ) ); }
                                                                            member(A) ::= membervisibility membertype Function Operator Identifier parameterlist Colon statementblock. { A = nullptr; /* not implemented */ }

                                                                                %type membertype { ast::expr::Class::Member::Type }
                                                                                membertype(A) ::= Static. { A = ast::expr::Class::Member::Type::Static; }
                                                                                membertype(A) ::= . { A = ast::expr::Class::Member::Type::Binded; }

                                                                                %type membervisibility { ast::expr::Class::Member::Visibility }
                                                                                membervisibility(A) ::= Public. { A = ast::expr::Class::Member::Visibility::Public; }
                                                                                membervisibility(A) ::= Protected. { A = ast::expr::Class::Member::Visibility::Protected; }
                                                                                membervisibility(A) ::= Private. { A = ast::expr::Class::Member::Visibility::Private; }
